#ifndef _RSA_H
#define _RSA_H

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>

#define RSA_SIEVE_LIMIT 255

/*
 * Using information found from Sieve of Eratosthenes Algorithm https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes, the algorithm will be used 
 * for the generation of a public and a private key. Particulartly, a boolean array is created where every value is true. With a for-loop, an index position
 * that is not corresponded in a prime number is searched. The value is turned to false and starting from the smallest prime (being 2) their is a counter that
 * saves the increments of the number. The true values (meaning the prime numbers of the array) indicate the prime_sz and are used to allocate the memory 
 * needed to make the array of primes.
 *
 * Input:
 * int limit: A limit
 * int * prime_sz: The size of the generated primes list. Empty argument used as ret val
 *
 * Output:
 * The prime numbers that are less or equal to the limit
 */
size_t * sieve_of_eratosthenes(int, int *);


/*
 * Greatest Common Denominator
 *
 * Input:
 * a: first number
 * b: second number
 *
 * Output
 * The GCD of the two number provided
 */
int gcd(int , int);


/*
 * Chooses a number 'e' where 1 < e < fi(n) AND gcd(e, fi(n)) == 1
 *
 * Input:
 * arg0: fi(n)
 *
 * Output:
 * Returns the number found
 */
size_t choose_e(size_t);


/*
 * Calculates the modular inverse
 *
 * Input:
 * a: first number
 * b: second number
 *
 * Output:
 * The modular inverse of the numbers provided
 */
size_t mod_inverse(size_t, size_t);


/*
 * This function generates an RSA key pair and saves each key in a different file.
 * A pool of prime numbers is created using Sieve of Eratosthenes Algorithm. Two random prime numbers (p, q) are choosen, then are used
 * for computing n where n = p*q and for later calculating fi(n) where fi(n) = (p-1)*(q-1). A number e is generated with requirement of being
 * 1 < e < fi(n) AND gcd(e, fi(n)) == 1 and a number d is generated by mod_inverse().
 * 
 * Output: 
 * There is no return value, but a public.key is created by writing the n and d numbers of the algorithm and a private.key is created by writing
 * the n and e numbers of the algorithm
 */
void rsa_keygen(void);


/*
 * Encrypts an input file and dumps the ciphertext into an output file. For each character of the plaintext in the input file,
 * the cipher of this character is calculated according to https://en.wikipedia.org/wiki/RSA_(cryptosystem) in "Encryption" and
 * all the ciphertext is passed to a pointer in a file named as the output_file suggests. The ciphertext will have length of 
 * input_len * sizeof(size_t).
 *
 * Input:
 * input_file: path to input file
 * output_file: path to output file
 * key_file: path to key file
 * 
 * Output:
 * There is no return value, a file is created that contains the ciphertext
 */
void rsa_encrypt(char *, char *, char *);


/*
 * Decrypts an input file and dumps the plaintext into an output file. The memory allocation of the plaintext that will be produced 
 * by the ciphertext is the input_len (ciphertext length) divided by size of size_t (8), as this is the difference between size_t bytes
 * with char bytes.
 *
 * input_file: path to input file
 * output_file: path to output file
 * key_file: path to key file
 * 
 * Output:
 * There is no return value, a file is created that contains the decrypted text
 */
void rsa_decrypt(char *, char *, char *);

#endif /* _RSA_H */
